# 分布式系统中的一致性

一致性可能是分布式系统中最容易被误解的概念之一。我认为至少有两个原因。

首先，**一致性**这个术语被过度使用了。与关系型数据库（尤其是事务）打交道的工程师都知道 **ACID** 这个缩写，其中的 **C** 代表 **Consistency（一致性）**。与 NoSQL 数据库打交道的工程师听说过 **BASE** 这个缩写，其中的 **E** 也代表一致性，但这次前面加了 **Eventual（最终）** 这个词。使用 Cassandra 数据库的工程师知道一致性是**可调的**。许多人听说过 **CAP 定理**，其中也涉及一致性。

这些术语都指的是同一种一致性吗？**不是。**

- **ACID 一致性**描述的是**事务一致性**，它保证在执行事务时，不会违反数据库约束。例如，在两个账户之间转账时，总金额必须保持不变。

上述所有术语都涉及数据复制和多份数据之间的一致性。这三个术语也不相等。每个术语都暗示了不同的系统行为。我们稍后会详细说明。

第二个问题是，一致性很复杂。试着阅读关于一致性模型的维基百科页面。谢谢，不用了。我们需要了解并理解一致性的细微差别。所以我会尝试提炼关键概念，并专注于这些内容。

请坐好，我给你讲个故事。

## 简短的历史

在过去的年代，比如 2000 年初，工程师的生活很简单。一个关系型数据库实例就足以处理许多热门网站的流量。我可能有点夸张。但那已经是很久以前的事了，历史变成了传说。

当只有一份数据时，编写应用程序和测试它们都很容易。当你向数据库写入数据，然后读取它时，你总是知道会得到什么值。

## 数据复制的兴起

互联网流量增长迅速，数据复制成为热门网站（尤其是社交网络服务）的必要条件。而主要原因不是为了持久性，而是为了**读扩展性**。因为社交媒体网站的读操作非常多，每个副本都可以独立地处理读请求。提高可用性和持久性是复制的两个额外好处。

现在，在存在多份数据的情况下，我们有两个选择：

1. 要求分布式系统像以前一样工作，当时只有一份数据，即所有副本始终保持同步。
2. 放弃这种想法，接受一个新的常态——数据副本在合理的时间内可能不同步。换句话说，接受存在多份不同数据的事实。

如果我们选择第一个选项，我们可以声称我们的系统提供了**强一致性**。选择第二个选项，我们的系统提供了**弱一致性**。

回到过去，人们很聪明，他们认为“强”和“弱”这样的词太模糊了。多强？多弱？如果以后我们提出一种比弱一致性更强但比强一致性更弱的一致性类型呢？我们应该怎么命名？中等一致性？

所以他们决定给不同的一致性类型指定具体的名称。此外，他们为每种一致性类型定义了一组规则——这些规则定义了系统中更新的顺序，以及这些更新何时对用户可见。这样的规则集合被称为**一致性模型**。事实上，人们发明了许多一致性模型。

让我们提到一些流行的模型。

## 一致性模型

### 线性一致性（Linearizability）

第一个是一致性模型是**线性一致性**。这是在分布式系统中可以实现的最强一致性模型。让我明确一点：理论上，还有一个更强的一致性模型，称为**严格一致性（Strict Consistency）**，但严格一致性模型纯粹是理论上的，无法在实践中实现。所以线性一致性是实践中可以实现的最强模型。

**线性一致性**意味着在更新完成后，所有客户端在读取数据时，都能得到更新后的值。尽管系统中有多个数据副本，线性一致性系统创造了单一数据副本的幻觉。

当你听到有人在分布式系统的上下文中谈论强一致性时，他们很可能指的是线性一致性。但最好让他们确认一下。

线性一致性是一个很好的模型，易于理解。我们在跟踪一些余额的系统中使用线性一致性——银行账户余额、在线商店产品库存、机票等。当余额发生变化时，我们希望所有客户端都有相同的视图。

但线性一致性有两个主要缺点：

1. **性能**：线性一致性很慢。
2. **CAP 定理**：著名的 CAP 定理告诉我们，在网络分区（即网络故障）的情况下，我们只能在线性一致性和可用性之间选择一个，不能同时拥有。

我需要强调的是，CAP 定理有许多细微之处，值得深入探讨。目前，我希望你记住 CAP 定理的两点：

- CAP 中的 **C** 表示 **强一致性**，更具体地说，是**线性一致性**。
- 只有在**网络分区**的情况下，我们才需要在一致性和可用性之间进行选择。如果网络可靠，我们不需要在它们之间选择。可用性和强一致性都可以满足。

由于这两个缺点，许多系统更倾向于放弃线性一致性，转而使用弱一致性模型，如**最终一致性**。

### 最终一致性

**最终一致性**意味着，如果对象没有新的更新，最终所有读取都会返回该对象的最新写入值，即在所有副本同步后。

最终一致性是一种较弱的保证，因为它并未指定复制何时完成。如果系统中没有故障，复制会很快发生，可能是毫秒或几秒内。但当系统出现问题时，一些副本可能会落后，当读取请求命中它们时，它们会继续返回旧的值，而其他副本返回新值。

最终一致性可能比线性一致性快得多，特别是在副本地理分布的情况下。另一个优点是，我们不需要牺牲可用性。在网络分区的情况下，我们可以同时拥有可用性和最终一致性。

但就像所有事物一样，最终一致性模型也有缺点。

#### 最终一致性的缺点

最终一致性可能会导致很多混淆。例如：

- **评论消失**：你在博客文章下阅读评论。最初只有一条评论，你看到了。稍后，刷新页面后，你再也看不到任何评论了。唯一的评论突然消失了。
  - **发生了什么？** 最初，评论由一个副本返回。刷新后，另一个副本处理读取请求，而该副本尚未知道该评论。

- **更新延迟**：你写了一条评论并按下发送按钮。页面刷新后，你的评论不在页面上。再刷新几次后，你终于看到了你的评论。
  - **发生了什么？** 你的评论尚未传播到所有副本。你读取的副本尚未拥有该评论。

- **更新顺序错误**：在重读你的第一条评论后，你决定添加另一条评论以澄清一些细节。你按下发送按钮，页面刷新，你在页面上看到了你的两条评论，但顺序是错的。你的第一条评论在第二条评论之后，这完全扰乱了你的消息逻辑。

  - **发生了什么？** 数据库系统是分片的，系统中有多个实例（分片）并行处理写入，每个分片都有自己的一组副本。你的第一条评论由一个分片处理，而第二条评论由另一个分片处理。尽管第一个分片比第二个分片更早获得了第一条评论，但第二个分片更快地完成了复制。现在，当我们读取评论时，系统认为第二条评论较早，因为它首先在副本上创建。如果两个分片的时钟时间不同，也可能发生类似的问题。

看到这些，你关闭了网站，并发誓再也不打开它了。

## 超越最终一致性

我可以继续讲下去，但请让我在这里停下来，提醒你过去的人们很聪明。他们创建了一致性模型，帮助解决了上述所有问题。这些一致性模型比最终一致性模型更强，但比线性一致性更弱。

- **单调读取**：解决了数据似乎消失和重新出现的问题。
- **读己之写**：确保你总是能看到自己的更新。
- **一致的前缀读取**：确保以一致的顺序看到数据。

在课程的后面，我们将讨论如何实现这些模型，当然还包括最终一致性和线性一致性。

需要注意的是，这三个模型中没有一个比另外两个更强。在幻灯片上，它们看起来按强度排序，但事实并非如此。我只是想不出更好的图形来展示这一点。我们只能说，这三个模型比最终一致性更强，比线性一致性更弱。
